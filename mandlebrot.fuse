
decl int_c_real: fix<64, 32>[4096];
decl int_c_img: fix<64, 32>[4096];
decl int_outputs: bit<1>[4096];

let c_real_mem: fix<64, 32>[4096 bank 1];
let c_img_mem: fix<64, 32>[4096 bank 1];
let z_img_mem: fix<64, 32>[4096 bank 1];
let z_real_mem: fix<64, 32>[4096 bank 1];
let outputs: bit<1>[4096 bank 1];

view c_real_sh = c_real_mem[_: bank 1];
view c_img_sh = c_img_mem[_: bank 1];

// copy inputs into memory
for (let i: ubit<13> = 0..4096) {
  c_real_sh[i] := int_c_real[i];
  c_img_sh[i] := int_c_img[i];
}

// initialize z, outputs
for (let i: ubit<13> = 0..4096) unroll 1 {
  z_img_mem[i] := (0.0 as fix<64, 32>);
  z_real_mem[i] := (0.0 as fix<64, 32>);
  outputs[i] := 1; // by default everything is in the set
}

---

for (let i: ubit<13> = 0..4096) unroll 1 {
  let c_real = c_real_mem[i];
  let c_img = c_img_mem[i];
  for (let n_iters: ubit<6> = 0..32) {
    let z_real = z_real_mem[i];
    let z_img = z_img_mem[i];
    ---
    let z_img_2 = z_img * z_img;
    let z_real_2 = z_real * z_real;
    if (outputs[i] == 0 || z_img_2 < (0.0 as fix<64, 32>) || z_real_2 < (0.0 as fix<64, 32>) || z_img_2 + z_real_2 < (0.0 as fix<64, 32>) || z_img_2 + z_real_2 > (4.0 as fix<64, 32>)) {
      outputs[i] := 0;
    } else {
      z_real_mem[i] := z_real_2 - z_img_2 + c_real;
      let ixr = z_img * z_real;
      let doub_ixr = (2.0 as fix<64, 32>) * ixr;
      z_img_mem[i] := doub_ixr + c_img;
    }
  }
}

---

view outputs_sh = outputs[_: bank 1];

// copy outputs
for (let i: ubit<13> = 0..4096) {
  int_outputs[i] := outputs_sh[i];
}